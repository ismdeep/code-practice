/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author ismdeep
 */

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <stack>
#include <vector>
#include <algorithm>
#include <list>
#include <map>
#include <queue>
#include <bitset>
#include <numeric>
#include <sstream>
#include <limits>

using namespace std;


#define TIMES(id, size) for(int id = 0; id < (size); ++id)
#define FOR(type_id, id, from, to, step) for(type_id id = (from); id <= (to); id += step)
#define DBG(x) \
    (void)(cout << "L" << __LINE__ \
    << ": " << #x << " = " \
    << (x) << '\n')

#ifndef _BITS_STDINT_UINTN_H
typedef unsigned long long uint64_t;
#endif
typedef unsigned char uint8_t;

struct Point2D {
    int x, y, step;

    Point2D(){}

    Point2D(int _x, int _y, int _step) {
        this->x = _x;
        this->y = _y;
        this->step = _step;
    }
    bool operator == (Point2D p) {
        return this->x == p.x && this->y == p.y;
    }

    bool in_map (int x_min, int x_max, int y_min, int y_max) {
        return x_min <= this->x && this->x <= x_max && y_min <= this->y && this->y <= y_max;
    }

    string ToString() {
        char ch[1024];
        sprintf(ch, "{x:%d, y:%d, step:%d}", this->x, this->y, this->step);
        string str = ch;
        return str;
    }
};

struct Point3D {
    int x, y, z, step;

    Point3D() {}

    Point3D(int _x, int _y, int _z, int _step) {
        this->x = _x;
        this->y = _y;
        this->z = _z;
        this->step = _step;
    }

    bool operator==(Point3D p) {
        return this->x == p.x && this->y == p.y && this->z == p.z;
    }

    string ToString() {
        char ch[1024];
        sprintf(ch, "{x:%d, y:%d, z:%d, step:%d}", this->x, this->y, this->z, this->step);
        string str = ch;
        return str;
    }
};


void* create_array(size_t size, size_t sizeof_item) {
    void * arr = malloc(sizeof_item * size);
    return arr;
}

void** create_matrix(size_t rows, size_t cols, size_t sizeof_item) {
    void ** arr = (void **)malloc(sizeof(size_t) * rows);
    for (size_t row_id = 0; row_id < rows; ++row_id) {
        arr[row_id] = malloc(sizeof_item * cols);
    }
    return arr;
}

void*** create_cube(size_t x, size_t y, size_t z, size_t sizeof_item) {
    void*** arr = (void ***) malloc(sizeof(void**) * x);
    for (size_t x_id = 0; x_id < x; ++x_id) {
        arr[x_id] = (void **) malloc(sizeof(void*) * y);
        for (size_t y_id = 0; y_id < y; ++y_id) {
            arr[x_id][y_id] = malloc(sizeof_item * z);
        }
    }
    return arr;
}



int dir[4][2] = {
        {1,  0},
        {-1, 0},
        {0,  1},
        {0,  -1}
};

void init_visited(bool **visited) {
    TIMES(i, 7) {
        TIMES(j, 7) {
            visited[i][j] = true;
        }
    }
}

class POJ3984 {
public:
    void solve(std::istream &in, std::ostream &out) {
        bool **visited = (bool **) create_matrix(7, 7, sizeof(bool));
        Point2D **prev = (Point2D **) create_matrix(7, 7, sizeof(Point2D));
        prev[0][0].x = 0;
        prev[0][0].y = 0;
        FOR(int, i, 1, 5, 1) {
            FOR(int, j, 1, 5, 1) {
                in >> visited[i][j];
            }
        }
        visited[1][1] = true;
        queue<Point2D> q;
        q.push(Point2D(1, 1, 0));
        while (!q.empty()) {
            Point2D cur = q.front();
            q.pop();
            cout << "Hello" << endl;
            TIMES(dir_id, 4) {
                Point2D next(cur.x + dir[dir_id][0], cur.y + dir[dir_id][1], cur.step + 1);
                if (!visited[next.x][next.y]) {
                    q.push(next);
                    prev[next.x][next.y].x = cur.x;
                    prev[next.x][next.y].y = cur.y;
                    // visited[next.x][next.y] = true;
                }
            }
        }
        out << "Hello" << endl;
        out << prev[5][5].x << " " << prev[5][5].y << endl;
    }
};


int main() {
	POJ3984 solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
