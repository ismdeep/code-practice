/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author ismdeep
 */

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <stack>
#include <vector>
#include <algorithm>
#include <list>
#include <map>
#include <queue>
#include <bitset>
#include <numeric>
#include <sstream>
#include <limits>

using namespace std;


#define TIMES(id, size) for(int id = 0; id < (size); ++id)
#define FOR(type_id, id, from, to, step) for(type_id id = (from); id <= (to); id += step)
#define DBG(x) \
    (void)(cout << "L" << __LINE__ \
    << ": " << #x << " = " \
    << (x) << '\n')

typedef unsigned long long uint64_t;
typedef unsigned char uint8_t;

struct Point2D {
    int x, y, step;

    Point2D(){}

    Point2D(int _x, int _y, int _step) {
        this->x = _x;
        this->y = _y;
        this->step = _step;
    }
    bool operator == (Point2D p) {
        return this->x == p.x && this->y == p.y;
    }

    bool in_map (int x_min, int x_max, int y_min, int y_max) {
        return x_min <= this->x && this->x <= x_max && y_min <= this->y && this->y <= y_max;
    }

    string ToString() {
        char ch[1024];
        sprintf(ch, "{x:%d, y:%d, step:%d}", this->x, this->y, this->step);
        string str = ch;
        return str;
    }
};

struct Point3D {
    int x, y, z, step;

    Point3D() {}

    Point3D(int _x, int _y, int _z, int _step) {
        this->x = _x;
        this->y = _y;
        this->z = _z;
        this->step = _step;
    }

    bool operator==(Point3D p) {
        return this->x == p.x && this->y == p.y && this->z == p.z;
    }

    string ToString() {
        char ch[1024];
        sprintf(ch, "{x:%d, y:%d, z:%d, step:%d}", this->x, this->y, this->z, this->step);
        string str = ch;
        return str;
    }
};


void* create_array(size_t size, size_t sizeof_item) {
    void * arr = malloc(sizeof_item * size);
    return arr;
}

void** create_matrix(size_t rows, size_t cols, size_t sizeof_item) {
    void ** arr = (void **)malloc(sizeof(size_t) * rows);
    for (size_t row_id = 0; row_id < rows; ++row_id) {
        arr[row_id] = malloc(sizeof_item * cols);
    }
    return arr;
}

void*** create_cube(size_t x, size_t y, size_t z, size_t sizeof_item) {
    void*** arr = (void ***) malloc(sizeof(void**) * x);
    for (size_t x_id = 0; x_id < x; ++x_id) {
        arr[x_id] = (void **) malloc(sizeof(void*) * y);
        for (size_t y_id = 0; y_id < y; ++y_id) {
            arr[x_id][y_id] = malloc(sizeof_item * z);
        }
    }
    return arr;
}


int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};


void bfs_map(bool **visited, Point2D *start, bool **is_kfc, int** step_count) {
    visited[start->x][start->y] = true;
    queue<Point2D> q;
    q.push(*start);
    while (!q.empty()) {
        Point2D cur = q.front(); q.pop();
        step_count[cur.x][cur.y] = cur.step;
        TIMES(dir_id, 4) {
            Point2D next(cur.x + dir[dir_id][0], cur.y + dir[dir_id][1], cur.step + 1);
            if (!visited[next.x][next.y]) {
                q.push(next);
                visited[next.x][next.y] = true;
            }
        }
    }
}

void init(std::istream &in, bool **visited_y, bool **visited_m, int **step_count_y, int **step_count_m, int n, int m, bool **is_kfc, Point2D &point_y, Point2D &point_m) {
    TIMES(i, n + 2) {
        TIMES(j, m + 2) {
            visited_y[i][j] = true;
            visited_m[i][j] = true;
            is_kfc[i][j] = false;
        }
    }
    /* Input START */
    string str;
    FOR (int, i, 1, n, 1) {
        in >> str;
        FOR (int, j, 1, m, 1) {
            step_count_y[i][j] = 0x3fffffff;
            step_count_m[i][j] = 0x3fffffff;
            if ('Y' == str[j - 1]) {
                point_y.x = i;
                point_y.y = j;
                point_y.step = 0;
                visited_y[i][j] = true;
                visited_m[i][j] = false;
            } else if ('M' == str[j - 1]) {
                point_m.x = i;
                point_m.y = j;
                point_m.step = 0;
                visited_y[i][j] = false;
                visited_m[i][j] = true;
            } else if ('@' == str[j-1]) {
                is_kfc[i][j] = true;
                visited_y[i][j] = false;
                visited_m[i][j] = false;
            } else if ('#' == str[j-1]) {
                visited_y[i][j] = true;
                visited_m[i][j] = true;
            } else {
                visited_y[i][j] = false;
                visited_m[i][j] = false;
            }
        }
    }
    /* Input END */
}


class HDU2612 {
public:
    void solve(std::istream &in, std::ostream &out) {
        int n, m;
        string str;
        while (in >> n >> m) {
            bool **visited_y = (bool **) create_matrix(n + 2, m + 2, sizeof(bool));
            bool **visited_m = (bool **) create_matrix(n + 2, m + 2, sizeof(bool));
            bool **is_kfc    = (bool **) create_matrix(n + 2, m + 2, sizeof(bool));
            int **step_count_y = (int **) create_matrix(n + 2, m + 2, sizeof(int));
            int **step_count_m = (int **) create_matrix(n + 2, m + 2, sizeof(int));
            Point2D point_y;
            Point2D point_m;

            init(in, visited_y, visited_m, step_count_y, step_count_m, n, m, is_kfc, point_y, point_m);

            bfs_map(visited_y, &point_y, is_kfc, step_count_y);
            bfs_map(visited_m, &point_m, is_kfc, step_count_m);

            int ans = 0x3fffffff;
            FOR (int, i, 1, n, 1) {
                FOR (int, j, 1, m, 1) {
                    if (is_kfc[i][j]) {
                        ans = min(ans, step_count_m[i][j] + step_count_y[i][j]);
                    }
                }
            }
            out << ans * 11 << endl;
        }
    }
};


int main() {
	HDU2612 solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
